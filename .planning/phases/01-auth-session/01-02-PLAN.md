---
phase: 01-auth-session
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/community/src/lib/snowflake.ts
  - packages/community/src/lib/permissions.ts
  - packages/community/src/lib/auth.ts
autonomous: true
user_setup:
  - service: Snowflake
    why: "External OAuth Security Integration and custom roles for GDAI"
    env_vars:
      - name: SNOWFLAKE_ACCOUNT
        source: "Snowflake account identifier (e.g., myorg-myaccount) — from Snowflake Admin -> Accounts"
      - name: SNOWFLAKE_ELEVATED_ROLE
        source: "Name of the elevated Snowflake role (default: GDAI_ELEVATED)"
    dashboard_config:
      - task: "Create External OAuth Security Integration for Azure AD"
        location: "Snowflake worksheet (ACCOUNTADMIN) — CREATE SECURITY INTEGRATION gdai_azure_oauth TYPE = EXTERNAL_OAUTH ENABLED = TRUE EXTERNAL_OAUTH_TYPE = AZURE EXTERNAL_OAUTH_ISSUER = 'https://login.microsoftonline.com/<TENANT_ID>/v2.0' EXTERNAL_OAUTH_JWS_KEYS_URL = 'https://login.microsoftonline.com/<TENANT_ID>/discovery/v2.0/keys' EXTERNAL_OAUTH_TOKEN_USER_MAPPING_CLAIM = 'upn' EXTERNAL_OAUTH_SNOWFLAKE_USER_MAPPING_ATTRIBUTE = 'login_name' EXTERNAL_OAUTH_AUDIENCE_LIST = ('api://<SNOWFLAKE_APP_ID>') EXTERNAL_OAUTH_ANY_ROLE_MODE = 'ENABLE'"
      - task: "Create custom GDAI roles"
        location: "Snowflake worksheet (SECURITYADMIN) — CREATE ROLE GDAI_STANDARD; CREATE ROLE GDAI_ELEVATED; GRANT ROLE GDAI_STANDARD TO ROLE SYSADMIN; GRANT ROLE GDAI_ELEVATED TO ROLE SYSADMIN;"
      - task: "Grant GDAI roles to users"
        location: "Snowflake worksheet (SECURITYADMIN) — GRANT ROLE GDAI_STANDARD TO USER <user>; GRANT ROLE GDAI_ELEVATED TO USER <elevated_user>;"
      - task: "Verify user login_name matches Azure AD UPN for all ~100 users"
        location: "Snowflake worksheet — SELECT login_name FROM snowflake.account_usage.users WHERE login_name IS NOT NULL"
  - service: Microsoft Entra ID (Azure AD)
    why: "Snowflake resource scope must be added to token request"
    env_vars:
      - name: SNOWFLAKE_OAUTH_SCOPE
        source: "The delegated scope URI from the Snowflake Resource app registration (e.g., api://<SNOWFLAKE_APP_ID>/session:role-any)"
    dashboard_config:
      - task: "Update GDAI Client app's authorization scope to include Snowflake resource scope"
        location: "Azure Portal -> App registrations -> GDAI Client App -> API permissions -> Verify the Snowflake resource scope is granted"

must_haves:
  truths:
    - "After login, the system establishes a Snowflake connection using the authenticated user's own OAuth token"
    - "The permission tier (standard or elevated) is determined from the user's Snowflake role at login"
    - "Permission tier is cached in the JWT session — no per-request Snowflake call for authorization"
    - "Snowflake connections are per-request, not pooled across users"
    - "Elevated users have permissionTier 'elevated' in their session; standard users have 'standard'"
  artifacts:
    - path: "packages/community/src/lib/snowflake.ts"
      provides: "Per-request Snowflake connection factory using OAuth token"
      contains: "authenticator.*OAUTH"
      exports: ["createUserConnection", "querySnowflake"]
    - path: "packages/community/src/lib/permissions.ts"
      provides: "Permission tier resolution via IS_ROLE_IN_SESSION"
      contains: "IS_ROLE_IN_SESSION"
      exports: ["resolvePermissionTier"]
  key_links:
    - from: "packages/community/src/lib/auth.ts"
      to: "packages/community/src/lib/permissions.ts"
      via: "jwt callback calls resolvePermissionTier on initial sign-in"
      pattern: "resolvePermissionTier"
    - from: "packages/community/src/lib/permissions.ts"
      to: "packages/community/src/lib/snowflake.ts"
      via: "createUserConnection to establish Snowflake session for role check"
      pattern: "createUserConnection"
    - from: "packages/community/src/lib/snowflake.ts"
      to: "snowflake-sdk"
      via: "snowflake.createConnection with authenticator: 'OAUTH'"
      pattern: "authenticator.*OAUTH"
---

<objective>
Create the Snowflake per-request connection factory using OAuth token pass-through, implement permission tier resolution from Snowflake roles, and wire the tier check into the NextAuth JWT callback at login time.

Purpose: AUTH-02 (permission tier from Snowflake role), AUTH-03 (user-scoped Snowflake session). The tier value stored in session.permissionTier also provides the foundation for AUTH-05/AUTH-06 download enforcement, which is implemented in Phase 5 where the download UI exists.

Output: Working Snowflake OAuth connection factory, permission tier resolver, and updated auth.ts JWT callback that determines tier at login.
</objective>

<execution_context>
@/Users/Rob.Ford/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Rob.Ford/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-session/01-RESEARCH.md
@.planning/phases/01-auth-session/01-01-SUMMARY.md

Key files from Plan 01-01:
@packages/community/src/lib/auth.ts — JWT callback with placeholder permissionTier
@packages/community/src/types/next-auth.d.ts — Type augmentations including snowflake_token
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Snowflake per-request connection factory with OAuth authentication</name>
  <files>
    packages/community/src/lib/snowflake.ts
  </files>
  <action>
Create `packages/community/src/lib/snowflake.ts`:

1. Import `snowflake-sdk` (the `snowflake-sdk` package was added in Plan 01-01).

2. Implement `createUserConnection(accessToken: string): Promise<snowflake.Connection>`:
   - Call `snowflake.createConnection()` with:
     - `account: process.env.SNOWFLAKE_ACCOUNT!` (e.g., "myorg-myaccount")
     - `authenticator: "OAUTH"`
     - `token: accessToken` (the user's Azure AD access_token with Snowflake audience)
   - Wrap the callback-based `connection.connect()` in a Promise.
   - On error, reject with the error. On success, resolve with the connection.
   - Log nothing — errors propagate to callers.

3. Implement `querySnowflake(connection: snowflake.Connection, sql: string, binds?: snowflake.Binds): Promise<unknown[]>`:
   - Call `connection.execute()` with `sqlText`, `binds`, and `complete` callback.
   - Wrap in a Promise: reject on error, resolve with `rows ?? []`.
   - This is a thin wrapper — no retry logic, no logging, no mutation.

4. Implement `destroyConnection(connection: snowflake.Connection): void`:
   - Call `connection.destroy(() => {})` — fire-and-forget cleanup.
   - Used by callers after they're done with a per-request connection.

IMPORTANT: Do NOT implement connection pooling. Each request creates a new connection using the specific user's token. This ensures Snowflake's `CURRENT_USER()` and RLS policies resolve correctly per user.

IMPORTANT: The `snowflake-sdk` package uses a callback-based API. All public functions must return Promises wrapping the callbacks.

IMPORTANT: `snowflake-sdk` may not have clean ESM exports. If TypeScript complains about the import, use `import snowflake from 'snowflake-sdk'` or `const snowflake = require('snowflake-sdk')` depending on the module system. Check what works with the community package's Next.js configuration (App Router uses ESM by default but Node.js server components may need CommonJS interop).
  </action>
  <verify>
    - `packages/community/src/lib/snowflake.ts` exists
    - File exports `createUserConnection`, `querySnowflake`, `destroyConnection`
    - File uses `authenticator: "OAUTH"` in the connection config
    - File does NOT implement connection pooling
    - `yarn tsc --noEmit -p packages/community/tsconfig.json` compiles without errors (or with only expected env-related warnings)
  </verify>
  <done>
    Snowflake connection factory creates per-request connections using the user's OAuth access_token. No connection pooling. Callback-based SDK wrapped in Promises.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement permission tier resolution and wire into NextAuth JWT callback</name>
  <files>
    packages/community/src/lib/permissions.ts
    packages/community/src/lib/auth.ts
  </files>
  <action>
1. Create `packages/community/src/lib/permissions.ts`:

   Import `createUserConnection`, `querySnowflake`, `destroyConnection` from `./snowflake`.

   Implement `resolvePermissionTier(accessToken: string): Promise<"standard" | "elevated">`:
   - Read elevated role name from `process.env.SNOWFLAKE_ELEVATED_ROLE ?? "GDAI_ELEVATED"`.
   - Call `createUserConnection(accessToken)` to establish a Snowflake session.
   - Execute: `SELECT IS_ROLE_IN_SESSION('GDAI_ELEVATED') AS IS_ELEVATED` (use the role name variable, NOT string interpolation — use parameterized query with `binds`).

   Wait — `IS_ROLE_IN_SESSION` takes a string literal argument, not a bind variable. Snowflake does not support bind variables for function arguments in all contexts. Use template literal with the uppercase role name:
   ```typescript
   const elevatedRole = (process.env.SNOWFLAKE_ELEVATED_ROLE ?? "GDAI_ELEVATED").toUpperCase()
   const sql = `SELECT IS_ROLE_IN_SESSION('${elevatedRole}') AS IS_ELEVATED`
   ```
   This is safe because the value comes from an environment variable, not user input.

   - Parse the result: `rows[0]?.IS_ELEVATED === true` means elevated; anything else means standard.
   - Call `destroyConnection(conn)` in a `finally` block.
   - Wrap the entire function in try/catch. On ANY error (connection failure, query failure, etc.), return `"standard"` — fail closed. Do NOT throw — the login must succeed even if Snowflake is temporarily unreachable (user just gets standard tier).

2. Update `packages/community/src/lib/auth.ts`:

   Import `resolvePermissionTier` from `./permissions`.

   In the `jwt` callback, replace the placeholder `token.permissionTier = "standard"` with:
   ```typescript
   if (account) {
     token.access_token = account.access_token!
     token.expires_at = account.expires_at!
     token.refresh_token = account.refresh_token
     token.permissionTier = await resolvePermissionTier(account.access_token!)
   }
   ```

   Also update the `authorization.params.scope` to include a TODO and env-var reference for the Snowflake scope:
   ```typescript
   authorization: {
     params: {
       scope: [
         "openid",
         "profile",
         "email",
         "offline_access",
         process.env.SNOWFLAKE_OAUTH_SCOPE,
       ].filter(Boolean).join(" "),
     },
   },
   ```

   This allows the Snowflake resource scope to be added via environment variable without code changes. When `SNOWFLAKE_OAUTH_SCOPE` is set (e.g., `api://<snowflake-app-id>/session:role-any`), the access_token returned by Azure AD will include the Snowflake audience, making it valid for Snowflake OAuth connections.

   **Critical — Token Audience Issue (Research Open Question 3):**
   Azure AD issues different access_tokens for different resource audiences. If `SNOWFLAKE_OAUTH_SCOPE` is set, the SINGLE access_token returned will target the Snowflake resource audience. Microsoft Graph calls (if any) would need a separate token. Since GDAI does not call Microsoft Graph after login, this is acceptable — the access_token should target Snowflake exclusively.

   If the organization's Azure AD configuration requires an On-Behalf-Of (OBO) flow instead (i.e., the initial token targets Graph and a second token is needed for Snowflake), the implementation would change to:
   1. Store the Graph-audience token as `access_token`
   2. Exchange it for a Snowflake-audience token via OBO in the jwt callback
   3. Store the Snowflake token as `snowflake_token`

   For now, implement the simpler single-scope approach (Snowflake scope requested directly). Add a comment documenting the OBO fallback if the single-scope approach fails during integration testing:
   ```typescript
   // If SNOWFLAKE_OAUTH_SCOPE is set, the access_token targets Snowflake directly.
   // If Azure AD requires OBO flow instead, implement token exchange here and
   // store result in token.snowflake_token. See 01-RESEARCH.md Open Question 3.
   ```

IMPORTANT: `IS_ROLE_IN_SESSION` is case-sensitive. Always uppercase the role name.
IMPORTANT: Do NOT throw from `resolvePermissionTier` — fail closed to "standard".
  </action>
  <verify>
    All three changes must be confirmed as a unit (permissions.ts, auth.ts jwt callback, auth.ts authorization scope):
    - `packages/community/src/lib/permissions.ts` exists and exports `resolvePermissionTier`
    - `resolvePermissionTier` returns `"standard" | "elevated"` (never throws)
    - `resolvePermissionTier` calls `IS_ROLE_IN_SESSION` with uppercase role name
    - `resolvePermissionTier` calls `destroyConnection` in finally block
    - `packages/community/src/lib/auth.ts` imports `resolvePermissionTier` from `./permissions`
    - `packages/community/src/lib/auth.ts` jwt callback calls `resolvePermissionTier(account.access_token!)` on initial sign-in (when `account` is present)
    - `packages/community/src/lib/auth.ts` authorization.params.scope includes `process.env.SNOWFLAKE_OAUTH_SCOPE` via filter/join pattern
    - All three files (permissions.ts, auth.ts, snowflake.ts) compile together: `yarn tsc --noEmit -p packages/community/tsconfig.json`
  </verify>
  <done>
    Permission tier is resolved from Snowflake's IS_ROLE_IN_SESSION at login time and cached in the JWT. The auth scope dynamically includes the Snowflake resource scope when configured. Snowflake connections are user-scoped via OAuth token pass-through. AUTH-02 (permission tier) and AUTH-03 (user-scoped session) are implemented. session.permissionTier is available for downstream enforcement (AUTH-05/AUTH-06 in Phase 5).
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `yarn tsc --noEmit -p packages/community/tsconfig.json` passes
2. `snowflake.ts` creates per-request connections with `authenticator: "OAUTH"` — no pooling
3. `permissions.ts` queries `IS_ROLE_IN_SESSION` with uppercase role, returns "standard" on any error
4. `auth.ts` jwt callback calls `resolvePermissionTier` on initial sign-in
5. `auth.ts` authorization scope includes `SNOWFLAKE_OAUTH_SCOPE` env var
6. Token audience concern is documented with OBO fallback comment
</verification>

<success_criteria>
- Snowflake connection factory works with OAuth token pass-through
- Permission tier determined at login from Snowflake role
- Tier cached in JWT — no per-request Snowflake auth call
- Auth scope dynamically includes Snowflake resource scope
- Token audience issue documented with fallback strategy
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-session/01-02-SUMMARY.md`
</output>
