---
phase: 01-auth-session
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - packages/community/src/lib/auth.ts
  - packages/community/src/lib/session-watchdog.ts
  - packages/community/src/components/SessionProvider.tsx
  - packages/community/src/app/layout.tsx
autonomous: false
user_setup: []

must_haves:
  truths:
    - "When the Azure AD access_token expires, the system automatically refreshes it using the refresh_token without user intervention"
    - "When the refresh_token itself is invalid or expired, the user is prompted to re-authenticate via Microsoft SSO"
    - "When re-authentication is triggered, any in-progress workflow state is preserved in sessionStorage before redirect"
    - "After re-authentication, the user returns to their exact prior URL and workflow state is restored from sessionStorage"
    - "Elevated users can download artifact JSON; standard users cannot (enforced via session.permissionTier)"
  artifacts:
    - path: "packages/community/src/lib/auth.ts"
      provides: "Token refresh logic in JWT callback"
      contains: "refreshAccessToken"
    - path: "packages/community/src/lib/session-watchdog.ts"
      provides: "Client-side session error detection and workflow state checkpoint"
      contains: "RefreshTokenError"
      exports: ["useSessionWatchdog"]
    - path: "packages/community/src/components/SessionProvider.tsx"
      provides: "next-auth SessionProvider wrapper with watchdog integration"
      contains: "SessionProvider"
  key_links:
    - from: "packages/community/src/lib/auth.ts"
      to: "https://login.microsoftonline.com"
      via: "refreshAccessToken fetches new token from Microsoft token endpoint"
      pattern: "oauth2/v2.0/token"
    - from: "packages/community/src/lib/session-watchdog.ts"
      to: "packages/community/src/lib/auth.ts"
      via: "Detects session.error === 'RefreshTokenError' set by jwt callback"
      pattern: "RefreshTokenError"
    - from: "packages/community/src/components/SessionProvider.tsx"
      to: "packages/community/src/lib/session-watchdog.ts"
      via: "Renders useSessionWatchdog hook inside session context"
      pattern: "useSessionWatchdog"
    - from: "packages/community/src/app/layout.tsx"
      to: "packages/community/src/components/SessionProvider.tsx"
      via: "Root layout wraps children in SessionProvider"
      pattern: "SessionProvider"
---

<objective>
Implement access_token refresh via refresh_token rotation, client-side session expiry detection with workflow state preservation, and verify the permission tier enables download permission enforcement.

Purpose: AUTH-04 (session expiry handling + state preservation), AUTH-05/AUTH-06 (elevated download / standard no-download — verified via session.permissionTier availability).

Output: Automatic token refresh, graceful re-authentication on refresh failure with workflow state checkpointing, and session.permissionTier available to all client and server components for download permission checks.
</objective>

<execution_context>
@/Users/Rob.Ford/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Rob.Ford/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-session/01-RESEARCH.md
@.planning/phases/01-auth-session/01-01-SUMMARY.md
@.planning/phases/01-auth-session/01-02-SUMMARY.md

Key files from prior plans:
@packages/community/src/lib/auth.ts — JWT callback with permissionTier and placeholder refresh
@packages/community/src/types/next-auth.d.ts — Type augmentations including error field
@packages/community/src/app/layout.tsx — Root layout to wrap with SessionProvider
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement access_token refresh in JWT callback</name>
  <files>
    packages/community/src/lib/auth.ts
  </files>
  <action>
Add a `refreshAccessToken` function to `packages/community/src/lib/auth.ts`:

1. Define `async function refreshAccessToken(token: JWT): Promise<JWT>` (import `JWT` type from `next-auth/jwt`):
   - POST to `https://login.microsoftonline.com/${process.env.AUTH_MICROSOFT_ENTRA_ID_TENANT_ID}/oauth2/v2.0/token` with:
     - `client_id`: `process.env.AUTH_MICROSOFT_ENTRA_ID_ID!`
     - `client_secret`: `process.env.AUTH_MICROSOFT_ENTRA_ID_SECRET!`
     - `grant_type`: `"refresh_token"`
     - `refresh_token`: `token.refresh_token!`
     - `scope`: same scope string as the authorization config (openid profile email offline_access + SNOWFLAKE_OAUTH_SCOPE if set)
   - Use `URLSearchParams` for the body and native `fetch`.
   - On success (`response.ok`): return `{ ...token, access_token: newTokens.access_token, expires_at: Math.floor(Date.now() / 1000 + newTokens.expires_in), refresh_token: newTokens.refresh_token ?? token.refresh_token }`.
   - On failure: return `{ ...token, error: "RefreshTokenError" as const }`.
   - Wrap in try/catch: catch block returns `{ ...token, error: "RefreshTokenError" as const }`.

2. Add `AUTH_MICROSOFT_ENTRA_ID_TENANT_ID` to the env vars needed (extract from the issuer URL, or use a dedicated env var). The tenant ID is needed for the token endpoint URL. Add it to the user_setup if not already covered.

   Alternative: Parse the tenant ID from `AUTH_MICROSOFT_ENTRA_ID_ISSUER` (which is `https://login.microsoftonline.com/<TENANT_ID>/v2.0`):
   ```typescript
   const tenantId = process.env.AUTH_MICROSOFT_ENTRA_ID_ISSUER!.split('/')[3]
   ```
   This avoids adding another env var. Use this approach.

3. Update the `jwt` callback to call `refreshAccessToken` when the token is expired:
   ```typescript
   async jwt({ token, account }) {
     // Initial sign-in
     if (account) {
       token.access_token = account.access_token!
       token.expires_at = account.expires_at!
       token.refresh_token = account.refresh_token
       token.permissionTier = await resolvePermissionTier(account.access_token!)
       return token
     }
     // Token still valid — return as-is
     if (Date.now() < token.expires_at * 1000) {
       return token
     }
     // Token expired — attempt refresh
     return refreshAccessToken(token)
   }
   ```

IMPORTANT: Do NOT re-resolve the permission tier on refresh. The tier is determined once at login and cached for the session lifetime. Re-resolving on every refresh would add latency and Snowflake load for no benefit — role assignments don't change within a session.

IMPORTANT: The `scope` parameter in the refresh request must match the original authorization scope. Build it the same way (including SNOWFLAKE_OAUTH_SCOPE if set).

IMPORTANT: Add a 5-second buffer to the expiry check (`Date.now() < (token.expires_at - 5) * 1000`) to prevent edge cases where the token expires between the check and the Snowflake request.
  </action>
  <verify>
    - `refreshAccessToken` function exists in `packages/community/src/lib/auth.ts`
    - Function POSTs to Microsoft token endpoint with refresh_token grant
    - Function returns `{ ...token, error: "RefreshTokenError" }` on failure (never throws)
    - JWT callback calls `refreshAccessToken` when token is expired
    - JWT callback includes 5-second buffer in expiry check
    - Permission tier is NOT re-resolved on refresh
    - `yarn tsc --noEmit -p packages/community/tsconfig.json` compiles without errors
  </verify>
  <done>
    Access token is automatically refreshed when expired. On refresh failure, token.error is set to "RefreshTokenError" and propagated to the session. Permission tier persists across refreshes without additional Snowflake calls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create client-side session watchdog with workflow state preservation</name>
  <files>
    packages/community/src/lib/session-watchdog.ts
    packages/community/src/components/SessionProvider.tsx
    packages/community/src/app/layout.tsx
  </files>
  <action>
1. Create `packages/community/src/lib/session-watchdog.ts` (client-side module — add `"use client"` directive):

   Import `useSession` and `signIn` from `next-auth/react`.
   Import `useEffect` from `react`.

   Export `useSessionWatchdog()` custom hook:
   ```typescript
   "use client"

   import { useSession, signIn } from "next-auth/react"
   import { useEffect } from "react"

   const CHECKPOINT_KEY = "gdai:workflow-checkpoint"

   export function useSessionWatchdog() {
     const { data: session } = useSession()

     useEffect(() => {
       if (session?.error === "RefreshTokenError") {
         // Checkpoint workflow state before redirect
         try {
           const workflowState = captureWorkflowState()
           if (workflowState) {
             sessionStorage.setItem(CHECKPOINT_KEY, JSON.stringify(workflowState))
           }
         } catch {
           // sessionStorage may be unavailable — proceed without checkpoint
         }
         // Redirect to re-authenticate, returning to current URL after
         signIn("microsoft-entra-id", { callbackUrl: window.location.href })
       }
     }, [session?.error])
   }

   function captureWorkflowState(): Record<string, unknown> | null {
     // Placeholder: capture current workflow state from application state.
     // This will be implemented when the workflow UI exists (Phase 2+).
     // For now, capture the current URL path as minimal state.
     return {
       url: window.location.href,
       timestamp: Date.now(),
     }
   }

   export function restoreWorkflowState(): Record<string, unknown> | null {
     try {
       const raw = sessionStorage.getItem(CHECKPOINT_KEY)
       if (!raw) return null
       sessionStorage.removeItem(CHECKPOINT_KEY)
       return JSON.parse(raw) as Record<string, unknown>
     } catch {
       return null
     }
   }
   ```

   The `captureWorkflowState` function is a placeholder. When the workflow UI is built (Phase 2+), it will serialize the current DAG state, active node, form inputs, etc. The session-watchdog hook itself is complete — it detects the error and triggers re-auth.

   `restoreWorkflowState` reads and clears the checkpoint. It will be called by the main application component after sign-in.

2. Create `packages/community/src/components/SessionProvider.tsx` (client component):

   ```typescript
   "use client"

   import { SessionProvider as NextAuthSessionProvider } from "next-auth/react"
   import { useSessionWatchdog } from "@/lib/session-watchdog"
   import type { ReactNode } from "react"

   function SessionWatchdog() {
     useSessionWatchdog()
     return null
   }

   export function SessionProvider({ children }: { children: ReactNode }) {
     return (
       <NextAuthSessionProvider>
         <SessionWatchdog />
         {children}
       </NextAuthSessionProvider>
     )
   }
   ```

3. Update `packages/community/src/app/layout.tsx`:

   Import `SessionProvider` from `@/components/SessionProvider`.

   Wrap the `{children}` in the root layout's body with `<SessionProvider>`:
   ```tsx
   <body>
     <SessionProvider>
       {children}
     </SessionProvider>
   </body>
   ```

   Keep the root layout as a server component. The `SessionProvider` is a client component boundary — this is the standard Next.js pattern.

IMPORTANT: Use `sessionStorage` (tab-scoped), NOT `localStorage` (persists across tabs). This prevents stale state from one tab overwriting another.

IMPORTANT: The `captureWorkflowState` function is intentionally minimal now. Do NOT try to serialize application state that doesn't exist yet. The hook structure and checkpoint/restore API are what matter for AUTH-04.

IMPORTANT: `signIn("microsoft-entra-id", { callbackUrl: window.location.href })` ensures the user returns to their exact prior URL after re-authentication.
  </action>
  <verify>
    - `packages/community/src/lib/session-watchdog.ts` exists with `"use client"` directive
    - File exports `useSessionWatchdog` and `restoreWorkflowState`
    - Hook detects `session?.error === "RefreshTokenError"` and calls `signIn`
    - Hook writes to `sessionStorage` (not `localStorage`)
    - `packages/community/src/components/SessionProvider.tsx` exists with `"use client"` directive
    - SessionProvider wraps NextAuthSessionProvider and renders SessionWatchdog
    - `packages/community/src/app/layout.tsx` wraps children in SessionProvider
    - `yarn tsc --noEmit -p packages/community/tsconfig.json` compiles without errors
  </verify>
  <done>
    Client-side session watchdog detects token refresh failures, checkpoints minimal workflow state to sessionStorage, and redirects to re-authenticate. After re-auth, the user returns to their prior URL. The checkpoint/restore API is ready for workflow state serialization in future phases.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete auth flow end-to-end</name>
  <what-built>
    Complete Phase 1 auth flow:
    1. Microsoft SSO login (MicrosoftEntraID provider, JWT session strategy)
    2. Auth guard middleware blocking unauthenticated access
    3. Snowflake OAuth connection factory (per-request, user-scoped)
    4. Permission tier resolution from Snowflake role (IS_ROLE_IN_SESSION)
    5. Token refresh with error propagation
    6. Session watchdog with re-auth redirect
    7. session.permissionTier available for download permission checks
  </what-built>
  <how-to-verify>
    Prerequisites: Azure AD app registrations and Snowflake External OAuth Security Integration must be configured (see user_setup in Plans 01-01 and 01-02).

    1. Set required environment variables:
       - AUTH_MICROSOFT_ENTRA_ID_ID, AUTH_MICROSOFT_ENTRA_ID_SECRET, AUTH_MICROSOFT_ENTRA_ID_ISSUER
       - AUTH_SECRET
       - SNOWFLAKE_ACCOUNT, SNOWFLAKE_ELEVATED_ROLE, SNOWFLAKE_OAUTH_SCOPE

    2. Start the dev server: `cd packages/community && yarn dev`

    3. Navigate to http://localhost:3000 in a browser
       - Expected: Immediate redirect to Microsoft SSO login page
       - No GDAI UI should be visible before login

    4. Sign in with a Microsoft account that has a matching Snowflake user
       - Expected: Redirect back to http://localhost:3000 with a valid session

    5. Open browser dev tools -> Application -> Cookies
       - Expected: `next-auth.session-token` cookie exists (httpOnly, secure in production)

    6. Check the session via `fetch('/api/auth/session')` in the browser console
       - Expected: JSON with `user.email`, `permissionTier` ("standard" or "elevated"), `access_token` present

    7. Test with a user who has GDAI_ELEVATED role:
       - Expected: `permissionTier: "elevated"` in session

    8. Test with a user who does NOT have GDAI_ELEVATED role:
       - Expected: `permissionTier: "standard"` in session

    9. Wait for token expiry (or manually invalidate):
       - Expected: Next request triggers refresh transparently (no redirect)
       - If refresh fails: browser redirects to Microsoft SSO

    If Snowflake connection fails with error 390318 or 390144:
       - The Azure AD token audience does not match Snowflake's EXTERNAL_OAUTH_AUDIENCE_LIST
       - Verify SNOWFLAKE_OAUTH_SCOPE env var matches the scope defined on the Azure AD resource app
       - Verify EXTERNAL_OAUTH_AUDIENCE_LIST in the Snowflake security integration matches the Application ID URI
  </how-to-verify>
  <resume-signal>Type "approved" if the auth flow works end-to-end, or describe specific issues encountered.</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compilation: `yarn tsc --noEmit -p packages/community/tsconfig.json` passes
2. Token refresh logic handles both success and failure cases
3. Session watchdog detects RefreshTokenError and triggers re-auth
4. Workflow state checkpoint uses sessionStorage (tab-scoped)
5. SessionProvider wraps the application in root layout
6. session.permissionTier is available to all components for AUTH-05/AUTH-06 enforcement
7. End-to-end auth flow verified by human (checkpoint)
</verification>

<success_criteria>
- Access token refreshes automatically when expired
- Refresh failure triggers re-authentication with state preservation
- Workflow state checkpointed to sessionStorage before redirect
- User returns to prior URL after re-authentication
- session.permissionTier available for download permission checks
- End-to-end flow verified with real Microsoft SSO and Snowflake
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-session/01-03-SUMMARY.md`
</output>
